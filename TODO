DONE - created mkshm script in startup - maybe move mkshm to startup

DONE - ldms/shm - create an access shm lib

DONE - lib/shm -rename lib/loadconfig to something better

DONE add in Makefile to copy .so libraries to lib/bin so they can be easier linked with processes in proc

NOT DOING - no need, just attach each time - create a mkshm tool in proc

DONE make includes easier to manage (move to includes dir instead of next to src)

DONE - install/setenv.sh - make build shell script so bash variables can be set (base directory, for where to put bin, queues, and other temp data)

DONE update documentation on confluence for new mqueue system logging

maybe add a proxy process in 'proc' dir that reads measurements and hosts them on a TCP server as JSON packets (so the front end can grab them)

DONE (I think) add signal handlers for SIGKILL for any process using a network / file resouce
    - I think right now this is dlp closing files and decom closing it's socket

maybe add a status shared lib so processes can report their status
    -e.g. decom is up, decom network error, etc.

DONE - was in app/view_log.sh, now reads system.fifo instead of using strace - add a program that attaches to dlp and views it's stdout
    - use strace and look for write

DONE ish - look in startup/default/start_gsw (pipes to system.fifo) (not on the network, something else could do this though) - pipe out system messages to the UI? maybe don't do this
    - they would probably go out the network

DONE save the logs in shutdown_gsw

consider changing timestamping to be when log_message is called rather than inserted by DLP

maybe add an option to pass in a different VCM config file to shmctl process

consider adding priorities to system messages
    - show high priorities in a notification

look at using Grafana and InfluxDB for UI
    -I think can send data to influx over UDP
    -make a separate process to poll data and update influx
    -not sure how to set data as read? maybe have a unique nonce in the shmem that decom updates
        -if the nonce is the same, don't read it (nonce could just be a timestamp)


add locking to shared mem:
//    -a way for a reading process to mark the shmem as read
//    -a way for a writing process to mark the shmem as written
//    -think about multiple readers
//        -assign each reader a bit in the lock byte (writer sets it, reader clears it)
//    -the lock byte can only be modified in a mutex
^^^ don't do it this way
instead:
    -make a common block of shared mem that holds pthread mutexes/semaphores
    -control locking/unlocking of readers/writer(s) with those

add logging to the shm lib (currently does none)
    -log perror messages (using strerror)
